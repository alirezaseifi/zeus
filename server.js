require('dotenv').config();

const
    mongoose = require('mongoose'),
    webpush = require('web-push'),
    mime = require('mime-types'),
    http = require('http'),
    fs = require('fs');

// PUBLIC / PRIVATE KEYS can be generated by `webpush.generateVAPIDKeys()`
const vapidKeys = {
    publicKey: process.env.PUBLIC_KEY,
    privateKey: process.env.PRIVATE_KEY
};

webpush.setGCMAPIKey(process.env.SERVER_KEY);
webpush.setVapidDetails(
    'mailto:tomasloon@gmail.com',
    vapidKeys.publicKey,
    vapidKeys.privateKey
);

mongoose.Promise = Promise;
mongoose.connect(process.env.MONGO_DB, {
    useMongoClient: true
});

const Deal = mongoose.model('Deal', {
    url: String,
    title: String,
    created: { type: Date, default: Date.now }
    // price
    // from
    // to
    // alliance
    // airline
    // source
});

const Subscriber = mongoose.model('Subscriber', {
    subscription: String,
    unsubscribed: Date,
    created: { type: Date, default: Date.now }
});


// APP ITSELF

const respond = (res, status, data) => {
    res.writeHead(status, {
        'Content-Type': 'application/json'
    });
    res.end(data);
};

const json = (obj, status) => JSON.stringify({ status: status || 'ok', data: obj });

const post = (body, res) => {
    res.writeHead(200, {
        'Content-Type': 'application/json'
    });

    let data = JSON.parse(body);

    res.end(json(data));
};

const saveDeal = data => new Promise((resolve, reject) => {
    console.log(data);
    resolve();
    // (new Deal({
    //     url: '',
    //     title: ''
    // })).save(err => {
    //     if (err) {
    //         reject(err);
    //     } else {
    //         resolve();
    //     }
    // });
});

const saveSubscriber = data => new Promise((resolve, reject) => {
    const next = err => {
        if (err) {
            reject(err);
        } else {
            resolve();
        }
    };

    if (data.isSubscribed) {
        (new Subscriber({
            subscription: JSON.stringify(data.subscription)
        })).save(next);
    } else {
        Subscriber.findOneAndUpdate({
            subscription: JSON.stringify(data.subscription)
        }, {
            $set: {
                unsubscribed: Date.now()
            }
        }, next);
    }
});

const parseBody = req => new Promise((resolve, reject) => {
    let data = '';
    req.on('data', chunk => data += chunk);
    req.on('end', () => resolve(JSON.parse(data)));
});

const server = http.createServer(async (req, res) => {

    if (req.method === 'GET' && process.env.ENV === 'local') {
        const path = __dirname + (req.url === '/' ? '/index.html' : req.url);
        if (fs.existsSync(path)) {
            res.writeHead(200, {
                'Content-Type': mime.lookup(path) || 'application/json'
            });
            return res.end(fs.readFileSync(path));
        }
    }

    let body;
    if (req.method === 'POST') {
        body = await parseBody(req);
    }

    const ok = () => respond(res, 200, json('saved'));
    const error = err => respond(res, 500, json(err, 'error'));

    if (req.url === '/deal' && req.method === 'POST') {
        saveDeal(body).then(ok).catch(error);
    } else if (req.url === '/' && req.method === 'POST') {
        saveSubscriber(body).then(ok).catch(error);
    } else {
        res.writeHead(404, {
            'Content-Type': 'text/plain'
        });
        res.end();
    }
});

server.listen(process.env.PORT || 3000);